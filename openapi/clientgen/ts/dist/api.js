/* tslint:disable */
/* eslint-disable */
/**
 * Crypto Wallet REST API
 * REST API for air-gapped crypto wallets. Supports multiple cryptocurrencies with fiat currency conversion, future-proof.
 *
 * The version of the OpenAPI document: 1.0.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';
export const BroadcastPost200ResponseStatusEnum = {
    Success: 'success',
    Pending: 'pending',
    Failed: 'failed'
};
export const TransactionDirectionEnum = {
    Incoming: 'incoming',
    Outgoing: 'outgoing'
};
/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesPost: async (balancesPostRequest, options = {}) => {
            // verify required parameter 'balancesPostRequest' is not null or undefined
            assertParamExists('balancesPost', 'balancesPostRequest', balancesPostRequest);
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(balancesPostRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost: async (broadcastPostRequest, options = {}) => {
            // verify required parameter 'broadcastPostRequest' is not null or undefined
            assertParamExists('broadcastPost', 'broadcastPostRequest', broadcastPostRequest);
            const localVarPath = `/broadcast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastPostRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol
         * @param {string} address
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: async (cryptoSymbol, address, limit, offset, options = {}) => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('transactionsGet', 'cryptoSymbol', cryptoSymbol);
            // verify required parameter 'address' is not null or undefined
            assertParamExists('transactionsGet', 'address', address);
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol
         * @param {string} fromAddress
         * @param {string} toAddress
         * @param {string} amount
         * @param {number} [feeRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet: async (cryptoSymbol, fromAddress, toAddress, amount, feeRate, options = {}) => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('unsignedTxGet', 'cryptoSymbol', cryptoSymbol);
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'fromAddress', fromAddress);
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'toAddress', toAddress);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('unsignedTxGet', 'amount', amount);
            const localVarPath = `/unsigned-tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }
            if (fromAddress !== undefined) {
                localVarQueryParameter['from_address'] = fromAddress;
            }
            if (toAddress !== undefined) {
                localVarQueryParameter['to_address'] = toAddress;
            }
            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }
            if (feeRate !== undefined) {
                localVarQueryParameter['fee_rate'] = feeRate;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesPost(balancesPostRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesPost(balancesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.balancesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastPost(broadcastPostRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastPost(broadcastPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.broadcastPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol
         * @param {string} address
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsGet(cryptoSymbol, address, limit, offset, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(cryptoSymbol, address, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.transactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol
         * @param {string} fromAddress
         * @param {string} toAddress
         * @param {string} amount
         * @param {number} [feeRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsignedTxGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DefaultApiFp(configuration);
    return {
        /**
         *
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesPost(balancesPostRequest, options) {
            return localVarFp.balancesPost(balancesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost(broadcastPostRequest, options) {
            return localVarFp.broadcastPost(broadcastPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol
         * @param {string} address
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(cryptoSymbol, address, limit, offset, options) {
            return localVarFp.transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol
         * @param {string} fromAddress
         * @param {string} toAddress
         * @param {string} amount
         * @param {number} [feeRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options) {
            return localVarFp.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Get balances for multiple addresses and cryptocurrencies
     * @param {BalancesPostRequest} balancesPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balancesPost(balancesPostRequest, options) {
        return DefaultApiFp(this.configuration).balancesPost(balancesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Broadcast signed transaction
     * @param {BroadcastPostRequest} broadcastPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastPost(broadcastPostRequest, options) {
        return DefaultApiFp(this.configuration).broadcastPost(broadcastPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transaction history for an address
     * @param {string} cryptoSymbol
     * @param {string} address
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsGet(cryptoSymbol, address, limit, offset, options) {
        return DefaultApiFp(this.configuration).transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Generate an unsigned transaction
     * @param {string} cryptoSymbol
     * @param {string} fromAddress
     * @param {string} toAddress
     * @param {string} amount
     * @param {number} [feeRate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options) {
        return DefaultApiFp(this.configuration).unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(this.axios, this.basePath));
    }
}
