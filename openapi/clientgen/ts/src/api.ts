/* tslint:disable */
/* eslint-disable */
/**
 * Crypto Wallet REST API
 * REST API for air-gapped crypto wallets. Supports multiple cryptocurrencies with fiat currency conversion, future-proof. 
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BalanceGet200Response
 */
export interface BalanceGet200Response {
    /**
     * The cryptocurrency symbol
     * @type {string}
     * @memberof BalanceGet200Response
     */
    'crypto_symbol': string;
    /**
     * The queried address
     * @type {string}
     * @memberof BalanceGet200Response
     */
    'address': string;
    /**
     * Balance in the native cryptocurrency units
     * @type {number}
     * @memberof BalanceGet200Response
     */
    'crypto_balance': number;
    /**
     * The fiat currency symbol used for conversion
     * @type {string}
     * @memberof BalanceGet200Response
     */
    'fiat_symbol': string;
    /**
     * Equivalent value in the specified fiat currency
     * @type {number}
     * @memberof BalanceGet200Response
     */
    'fiat_value': number;
    /**
     * Current exchange rate (crypto to fiat)
     * @type {number}
     * @memberof BalanceGet200Response
     */
    'exchange_rate': number;
    /**
     * Timestamp when the balance was retrieved
     * @type {string}
     * @memberof BalanceGet200Response
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface BroadcastPost200Response
 */
export interface BroadcastPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'crypto_symbol': string;
    /**
     * Transaction hash/ID
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'transaction_id': string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'status': BroadcastPost200ResponseStatusEnum;
    /**
     * Human-readable status message
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'message': string;
    /**
     * Actual network fee paid
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'network_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastPost200Response
     */
    'timestamp': string;
}

export const BroadcastPost200ResponseStatusEnum = {
    Success: 'success',
    Pending: 'pending',
    Failed: 'failed'
} as const;

export type BroadcastPost200ResponseStatusEnum = typeof BroadcastPost200ResponseStatusEnum[keyof typeof BroadcastPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BroadcastPostRequest
 */
export interface BroadcastPostRequest {
    /**
     * The cryptocurrency symbol
     * @type {string}
     * @memberof BroadcastPostRequest
     */
    'crypto_symbol': string;
    /**
     * Base64 or hex encoded signed transaction
     * @type {string}
     * @memberof BroadcastPostRequest
     */
    'signed_tx': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error type
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Transaction hash/ID
     * @type {string}
     * @memberof Transaction
     */
    'transaction_id': string;
    /**
     * Block height (null if unconfirmed)
     * @type {number}
     * @memberof Transaction
     */
    'block_height'?: number;
    /**
     * Transaction timestamp
     * @type {string}
     * @memberof Transaction
     */
    'timestamp': string;
    /**
     * Transaction amount in crypto units
     * @type {string}
     * @memberof Transaction
     */
    'amount': string;
    /**
     * Transaction direction relative to the queried address
     * @type {string}
     * @memberof Transaction
     */
    'direction': TransactionDirectionEnum;
    /**
     * Number of confirmations
     * @type {number}
     * @memberof Transaction
     */
    'confirmations': number;
    /**
     * Transaction fee (for outgoing transactions)
     * @type {string}
     * @memberof Transaction
     */
    'fee_amount'?: string;
    /**
     * Source addresses
     * @type {Array<string>}
     * @memberof Transaction
     */
    'from_addresses'?: Array<string>;
    /**
     * Destination addresses
     * @type {Array<string>}
     * @memberof Transaction
     */
    'to_addresses'?: Array<string>;
}

export const TransactionDirectionEnum = {
    Incoming: 'incoming',
    Outgoing: 'outgoing'
} as const;

export type TransactionDirectionEnum = typeof TransactionDirectionEnum[keyof typeof TransactionDirectionEnum];

/**
 * 
 * @export
 * @interface TransactionsGet200Response
 */
export interface TransactionsGet200Response {
    /**
     * 
     * @type {string}
     * @memberof TransactionsGet200Response
     */
    'crypto_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionsGet200Response
     */
    'address': string;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionsGet200Response
     */
    'transactions': Array<Transaction>;
    /**
     * Total number of transactions for this address
     * @type {number}
     * @memberof TransactionsGet200Response
     */
    'total_count': number;
    /**
     * Whether there are more transactions available
     * @type {boolean}
     * @memberof TransactionsGet200Response
     */
    'has_more': boolean;
}
/**
 * 
 * @export
 * @interface UnsignedTxGet200Response
 */
export interface UnsignedTxGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'crypto_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'from_address': string;
    /**
     * 
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'to_address': string;
    /**
     * 
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'amount': string;
    /**
     * Calculated transaction fee
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'fee_amount': string;
    /**
     * Base64 or hex encoded unsigned transaction or PSBT
     * @type {string}
     * @memberof UnsignedTxGet200Response
     */
    'unsigned_tx': string;
    /**
     * Estimated transaction size in bytes
     * @type {number}
     * @memberof UnsignedTxGet200Response
     */
    'tx_size_bytes'?: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet: async (cryptoSymbol: string, address: string, fiatSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('balanceGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('balanceGet', 'address', address)
            const localVarPath = `/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (fiatSymbol !== undefined) {
                localVarQueryParameter['fiat_symbol'] = fiatSymbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost: async (broadcastPostRequest: BroadcastPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'broadcastPostRequest' is not null or undefined
            assertParamExists('broadcastPost', 'broadcastPostRequest', broadcastPostRequest)
            const localVarPath = `/broadcast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: async (cryptoSymbol: string, address: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('transactionsGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('transactionsGet', 'address', address)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet: async (cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('unsignedTxGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'fromAddress', fromAddress)
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'toAddress', toAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('unsignedTxGet', 'amount', amount)
            const localVarPath = `/unsigned-tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['from_address'] = fromAddress;
            }

            if (toAddress !== undefined) {
                localVarQueryParameter['to_address'] = toAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (feeRate !== undefined) {
                localVarQueryParameter['fee_rate'] = feeRate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balanceGet(cryptoSymbol, address, fiatSymbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.balanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BroadcastPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastPost(broadcastPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.broadcastPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(cryptoSymbol, address, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.transactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnsignedTxGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsignedTxGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceGet200Response> {
            return localVarFp.balanceGet(cryptoSymbol, address, fiatSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BroadcastPost200Response> {
            return localVarFp.broadcastPost(broadcastPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsGet200Response> {
            return localVarFp.transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedTxGet200Response> {
            return localVarFp.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Get balance for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {string} [fiatSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceGet200Response>;

    /**
     * 
     * @summary Broadcast signed transaction
     * @param {BroadcastPostRequest} broadcastPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BroadcastPost200Response>;

    /**
     * 
     * @summary Get transaction history for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsGet200Response>;

    /**
     * 
     * @summary Generate an unsigned transaction
     * @param {string} cryptoSymbol 
     * @param {string} fromAddress 
     * @param {string} toAddress 
     * @param {string} amount 
     * @param {number} [feeRate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedTxGet200Response>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Get balance for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {string} [fiatSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).balanceGet(cryptoSymbol, address, fiatSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Broadcast signed transaction
     * @param {BroadcastPostRequest} broadcastPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).broadcastPost(broadcastPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an unsigned transaction
     * @param {string} cryptoSymbol 
     * @param {string} fromAddress 
     * @param {string} toAddress 
     * @param {string} amount 
     * @param {number} [feeRate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(this.axios, this.basePath));
    }
}



