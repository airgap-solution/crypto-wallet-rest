/* tslint:disable */
/* eslint-disable */
/**
 * Crypto Wallet REST API
 * REST API for air-gapped crypto wallets. Supports multiple cryptocurrencies with fiat currency conversion, future-proof. 
 *
 * The version of the OpenAPI document: 1.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BalanceGet200Response {
    'crypto_symbol': string;
    'address': string;
    'crypto_balance': number;
    'fiat_symbol': string;
    'fiat_value': number;
    'exchange_rate': number;
    /**
     * Absolute change in fiat value over the last 24 hours
     */
    'change24h': number;
    'timestamp': string;
}
export interface BalancesPost200Response {
    'results'?: Array<BalancesPost200ResponseResultsInner>;
    'timestamp'?: string;
}
export interface BalancesPost200ResponseResultsInner {
    'crypto_symbol': string;
    'address': string;
    'crypto_balance': number;
    'fiat_symbol': string;
    'fiat_value': number;
    'exchange_rate': number;
    /**
     * Absolute change in fiat value over the last 24 hours
     */
    'change24h': number;
    'timestamp': string;
    /**
     * Error message if this specific balance fetch failed
     */
    'error'?: string;
}
export interface BalancesPostRequest {
    'requests': Array<BalancesPostRequestRequestsInner>;
    /**
     * Default fiat currency symbol for all requests if not specified individually
     */
    'fiat_symbol'?: string;
}
export interface BalancesPostRequestRequestsInner {
    /**
     * The cryptocurrency symbol (BTC, ETH, etc.)
     */
    'crypto_symbol': string;
    /**
     * The cryptocurrency address or xpub
     */
    'address': string;
    /**
     * The fiat currency symbol for conversion (USD, EUR, CAD, etc.)
     */
    'fiat_symbol'?: string;
}
export interface BroadcastPost200Response {
    'crypto_symbol': string;
    'transaction_id': string;
    'status': BroadcastPost200ResponseStatusEnum;
    'message': string;
    'network_fee'?: string;
    'timestamp': string;
}

export const BroadcastPost200ResponseStatusEnum = {
    Success: 'success',
    Pending: 'pending',
    Failed: 'failed'
} as const;

export type BroadcastPost200ResponseStatusEnum = typeof BroadcastPost200ResponseStatusEnum[keyof typeof BroadcastPost200ResponseStatusEnum];

export interface BroadcastPostRequest {
    'crypto_symbol': string;
    'signed_tx': string;
}
export interface ErrorResponse {
    'error': string;
    'message': string;
    'timestamp': string;
}
export interface Transaction {
    'transaction_id': string;
    'block_height'?: number;
    'timestamp': string;
    'amount': string;
    'direction': TransactionDirectionEnum;
    'confirmations': number;
    'fee_amount'?: string;
    'from_addresses'?: Array<string>;
    'to_addresses'?: Array<string>;
}

export const TransactionDirectionEnum = {
    Incoming: 'incoming',
    Outgoing: 'outgoing'
} as const;

export type TransactionDirectionEnum = typeof TransactionDirectionEnum[keyof typeof TransactionDirectionEnum];

export interface TransactionsGet200Response {
    'crypto_symbol': string;
    'address': string;
    'transactions': Array<Transaction>;
    'total_count': number;
    'has_more': boolean;
}
export interface UnsignedTxGet200Response {
    'crypto_symbol': string;
    'from_address': string;
    'to_address': string;
    'amount': string;
    'fee_amount': string;
    'unsigned_tx': string;
    'tx_size_bytes'?: number;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet: async (cryptoSymbol: string, address: string, fiatSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('balanceGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('balanceGet', 'address', address)
            const localVarPath = `/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (fiatSymbol !== undefined) {
                localVarQueryParameter['fiat_symbol'] = fiatSymbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesPost: async (balancesPostRequest: BalancesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'balancesPostRequest' is not null or undefined
            assertParamExists('balancesPost', 'balancesPostRequest', balancesPostRequest)
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(balancesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost: async (broadcastPostRequest: BroadcastPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'broadcastPostRequest' is not null or undefined
            assertParamExists('broadcastPost', 'broadcastPostRequest', broadcastPostRequest)
            const localVarPath = `/broadcast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: async (cryptoSymbol: string, address: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('transactionsGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('transactionsGet', 'address', address)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet: async (cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoSymbol' is not null or undefined
            assertParamExists('unsignedTxGet', 'cryptoSymbol', cryptoSymbol)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'fromAddress', fromAddress)
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('unsignedTxGet', 'toAddress', toAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('unsignedTxGet', 'amount', amount)
            const localVarPath = `/unsigned-tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoSymbol !== undefined) {
                localVarQueryParameter['crypto_symbol'] = cryptoSymbol;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['from_address'] = fromAddress;
            }

            if (toAddress !== undefined) {
                localVarQueryParameter['to_address'] = toAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (feeRate !== undefined) {
                localVarQueryParameter['fee_rate'] = feeRate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balanceGet(cryptoSymbol, address, fiatSymbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.balanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesPost(balancesPostRequest: BalancesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalancesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesPost(balancesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.balancesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BroadcastPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastPost(broadcastPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.broadcastPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(cryptoSymbol, address, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.transactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnsignedTxGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsignedTxGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get balance for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {string} [fiatSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceGet200Response> {
            return localVarFp.balanceGet(cryptoSymbol, address, fiatSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balances for multiple addresses and cryptocurrencies
         * @param {BalancesPostRequest} balancesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesPost(balancesPostRequest: BalancesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BalancesPost200Response> {
            return localVarFp.balancesPost(balancesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Broadcast signed transaction
         * @param {BroadcastPostRequest} broadcastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BroadcastPost200Response> {
            return localVarFp.broadcastPost(broadcastPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history for an address
         * @param {string} cryptoSymbol 
         * @param {string} address 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsGet200Response> {
            return localVarFp.transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an unsigned transaction
         * @param {string} cryptoSymbol 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {string} amount 
         * @param {number} [feeRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedTxGet200Response> {
            return localVarFp.unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Get balance for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {string} [fiatSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceGet200Response>;

    /**
     * 
     * @summary Get balances for multiple addresses and cryptocurrencies
     * @param {BalancesPostRequest} balancesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balancesPost(balancesPostRequest: BalancesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BalancesPost200Response>;

    /**
     * 
     * @summary Broadcast signed transaction
     * @param {BroadcastPostRequest} broadcastPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BroadcastPost200Response>;

    /**
     * 
     * @summary Get transaction history for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsGet200Response>;

    /**
     * 
     * @summary Generate an unsigned transaction
     * @param {string} cryptoSymbol 
     * @param {string} fromAddress 
     * @param {string} toAddress 
     * @param {string} amount 
     * @param {number} [feeRate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedTxGet200Response>;

}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Get balance for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {string} [fiatSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public balanceGet(cryptoSymbol: string, address: string, fiatSymbol?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).balanceGet(cryptoSymbol, address, fiatSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balances for multiple addresses and cryptocurrencies
     * @param {BalancesPostRequest} balancesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public balancesPost(balancesPostRequest: BalancesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).balancesPost(balancesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Broadcast signed transaction
     * @param {BroadcastPostRequest} broadcastPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public broadcastPost(broadcastPostRequest: BroadcastPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).broadcastPost(broadcastPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history for an address
     * @param {string} cryptoSymbol 
     * @param {string} address 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsGet(cryptoSymbol: string, address: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionsGet(cryptoSymbol, address, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an unsigned transaction
     * @param {string} cryptoSymbol 
     * @param {string} fromAddress 
     * @param {string} toAddress 
     * @param {string} amount 
     * @param {number} [feeRate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsignedTxGet(cryptoSymbol: string, fromAddress: string, toAddress: string, amount: string, feeRate?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsignedTxGet(cryptoSymbol, fromAddress, toAddress, amount, feeRate, options).then((request) => request(this.axios, this.basePath));
    }
}



